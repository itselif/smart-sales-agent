

# Service Design Specification
**Athentication documentation**
-Version:**`1.0.1`**

## Scope

This document provides a structured architectural overview of the `authentication` module of the project.The `authentication` module of the project is used to generate authentication and authorization specific code for all services 
but a more specific purpose of the module is also to store all required configuration to generate an automatic user service for the project which is named 'salesai-auth-service'.

So in this document you will find 

- The detailed configuration of the authetication module.

- The effect of the authetication configuration on the auth (user) service and the detailed structures of the auto-generated user service.

- The effect of the authetication configuration on the resource services and the detailed authentication and authorization structures of a resource server.

This document has been automatically generated based on the authetication module definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

* **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
* **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
* **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.





## Authentication Essentials 

Mindbricks provides a comprehensive authentication module that serves as the foundation for user management and security across all services. 
This module is designed to be flexible, allowing for the generation of authentication and authorization code tailored to project's specific needs.
Mindbricks supports multiple authentication strategies, for the first validation of the user, the auth service supports the following authentication strategies:
- **Password-based authentication**: Users can log in using a username and password.
- **Social login**: Users can authenticate using third-party providers like Google, Facebook, or GitHub.
- **Single Sign-On (SSO)**: Users can log in using an SSO provider, allowing for seamless access across multiple applications.  
- **API Key**: Services can authenticate using API keys for secure communication.
Once the user is validated through one of the above strategies, the user is granted a JWT token that can be used to access the protected resources of the service.

JWT tokens are generated by the auth service and can be used to access protected resources of the service. 
The JWT token is open and contains the user's identity and any additional claims required for authorization. 
The token is signed using a private RSA key, ensuring its integrity and authenticity. 
Once the JWT token is generated, it can be used to access protected resources of the service.

The JWT token is structured as follows:
```json
{
  "keyId": "716a8738ec3d499f84d58bda6ee772ce",
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "sub": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  loginDate: "2023-10-01T12:00:00Z"
}
```

Key id for a token represents the private-public key pair used to sign the token. To validate the signature of the token, 
the public key is used. Any service which will use the JWT token can request a publick ket from the auth service using the following endpoint:

```http
GET /publickey?keyId=[keyIdInToken]
```

Mindbricks generated services manages the key rotation automatically, so the public key is always up to date and valid for the JWT tokens generated by the auth service.
If you add any manual service to the project which should validate the JWT token, you can use the public key endpoint to get the public key and validate the JWT token signature.

The JWT token life cycle is configured in the authentication module of the project. This project uses the following configuration for the JWT token:
The token is valid for  days after it is issued.
And the private key used to sign the token is rotated every  days.

Note that when a new key is generated to sign the JWT tokens, the old key is still valid for the period of  days. 
So it is recommended to cache the old public keys for the period of  days to validate the JWT tokens issued with the old keys.


## The Login Definition

The login definition is a crucial part of the authentication module, as it defines how user and tenant model is defined.
In this section it is specified how users, user groups, and tenants are defined in the project's data model. 
These definitions allow Mindbricks to dynamically extract identity and authorization data from project-specific data objects.

### User Settings

**Super Admin User Email**: `admin@aadmin.com`**
The login email of the super admin user. This user has full permissions across the project and is not tenant-scoped.
If not defined, the project owner's email is used. 
This email must be unique and valid to support email-based features like verification and password reset.

Super admin user is created automatically when the project is initialized with a roleId of `superAdmin` and a userId of `f7103b85-fcda-4dec-92c6-c336f71fd3a2`. 

**Super Admin User Password**: Super admin user password is defined in this module as well, but masked in this document.
To edit it you can use the **User Settings** section of **Login Definition** chapter of the Mindbricks **Authentication Module**.

**Username Type**: 
The type of the username which is stored in the database and written to the session object for information purposes.: 
-`asFullName`: The username is stored in one property, `fullname`, and represents the full name of the user, which is a combination of first name and last name.
-`asNamePair`: The username is stored in two properties, `name` and `surname`, which are combined to form the full name of the user.

This project uses the `asNamePair` type, so the user name is stored in two properties, `name` and `surname`, which are combined to form the full name of the user. 
The session object will contain the `fullname` property, which is a combination of `name` and `surname` as well as the `name` and `surname` properties. 



**User Groups**:
The project supports user groups, which are used to group users together for easier management and authorization.
Since user grups are enabled, the auth service will automaticall create a `userGroup` and `userGroupMember` data objects
that will store the user groups and their members. You can create and manage user groups and 
their members using the related crud routes defined in this document.

User groups are not scoped to tenants, meaning that user groups are shared across all tenants.
This allows for a global user group management, where user groups can be created and managed across all tenants.
The user group data object will not contain a `` property, and the user groups can be created and managed by the super admin and admin users only.
This means that user groups are not tenant-specific and can be used across all tenants.



**Public User Registration**:
The project allows public user registration, meaning that users can register themselves without the need for an admin to create an account for them.
This is useful for projects that require user self-registration, such as social networks, forums, or any application where users need to create their own accounts.
The user registration process is handled by the auth service, which will create a new user data object in the database.
The user registration process will create a new user with the `userId` and `roleId` set to `user`, and the user will be able to log in using the username and password
they provided during registration. The reigstered user's roleId will be updated later to any other roleId by the super admin or admin users.
If any social login is enabled for the project, the user can also sign up using the social login providers. Note that when users register themselves using socila logi,
first all the data that can be provided by the social login provider will written to Redis cache with a key called socialCode,
and this code will be returned to the api consumer, which can be used to complete the registration process.



**Email Verification Required For Login**: 
The project requires email verification for user login, meaning that users must verify their email address before they can log in.
This is useful for projects that require email verification to ensure that users have provided a valid email address, such as social networks, forums, or any application where email verification is required.
The email verification process is handled by the auth service, which will send a verification email to the user's email address after they register or change their email address.
You can check the email verification details in the REST API documentation of the auth service.



**Email 2FA Is Not Required For Login**:
The project does not require email-based two-factor authentication (2FA) for user login, meaning that users can log in using only their username and password without providing a second factor of authentication.
This is useful for projects that do not require an additional layer of security for user login, such as enterprise applications, internal tools, or any application where email-based 2FA is not required.
While the email 2FA is not required, the auth service will still support email 2FA if it is configured in the verification services.
You can prefer email 2FA at any time before any action or make it optional which means that users can provide a second factor of authentication if they want to, but it is not required for
login. You can check the email 2FA details in the REST API documentation of the auth service.



**User Mobile Is Not Active**: 
The authetication module is not configured to support mobile numbers for users.



**User Auto Avatar Script**:
Mindbricks stores an avatar property inthe user data model automatically.
This project supports also automatic avatar generation for users with the following script configuretion.
The auth service will generate an avatar for each user when it is not specified in the registration process.

The script is defined in the authentication module and can be edited in the **User Settings** section of **Login Definition** chapter of the Mindbricks **Authentication Module**.
The script is executed when a new user is created, and it generates an avatar based on user properties.

```js
`https://gravatar.com/avatar/${LIB.common.md5(this.email ?? 'nullValue')}?s=200&d=identicon`
```



### Tenant Settings
This project is configured to support multi-tenancy, meaning that users and other data can be scoped to a specific tenant.
This allows for tenant-specific data management, where each tenant can have its own set of users and other data.
The tenant concept in the project is represented with the `store` and a data object with this name is created automatically by the auth service.
The `store` data object willl contain the id , fullname and avatar of each `store` tenant.
The id of the tenant will be represented with the storeId property in user and other data objects.


**Tenant Registration Is Not Public**:
The project does not allow public tenant registration, meaning that users cannot create new tenants themselves and an admin must create a tenant for them.
This is useful for projects that require tenant accounts to be created by an admin, such as enterprise applications, internal tools, or any application where tenant accounts need to be managed by an admin.
The tenant registration process and user registration is seperated, however since tenant registration is not public, the auth service will not also allow users to register themselves to the SaaS root as tenant owner.

However since user registration is configured as public above, tenant users' reigistraion process can be handled by the users themselves after the tenant and its owner user is created by the SaaS admin.
     



**Tenant Auto Avatar Script**:
Mindbricks stores an avatar property in the `store` data object model automatically.
This project supports also automatic avatar generation for tenants with the following script configuration.
The auth service will generate an avatar for each tenant when it is not specified in the registration process.  

```js
`https://gravatar.com/avatar/${LIB.common.md5(this.fullname)}?s=200&d=identicon`
```













## Verification Services

The project supports various verification services that enhance security and user experience. 
These services are designed to verify user identity through different channels, such as email and mobile, 
and can be configured to suit the project's needs. Please check the auth service API documentation for more details on how to use these services through the REST API.

A verification service is configured with the following settings:
-`verificationType`: The type of verification handling, which can be one of the following:
  -- `byCode`: The verification is handled by entering a code in the frontend.
  -- `byLink`: The verification is handled by clicking a link in the frontend, which will automatically verify the user through the auth service.
-`resendTimeWindow`: The time window in seconds during which the user can request a new verification code or link.
-`expireTimeWindow`: The time window in seconds after which the verification code or link will expire and become invalid.


### Password Reset By Email
The project supports password reset by email, allowing users to reset their passwords securely through a verification code sent to their registered email address.
This service is useful for projects that require users to reset their passwords securely, such as social networks, forums, or any application where password reset is required.
The password reset by email process is handled by the auth service, which will send a verification code to the user's email address after they request a password reset.

```json
{
    verificationType: "byLink",
    resendTimeWindow: 60,
    expireTimeWindow: 86400
}
```


### Password Reset By Mobile
The project supports password reset by mobile, allowing users to reset their passwords securely through a verification code sent to their registered mobile number.
This service is useful for projects that require users to reset their passwords securely, such as social networks, forums, or any application where password reset is required.
The password reset by mobile process is handled by the auth service, which will send a verification code to the user's mobile number after they request a password reset.   
```json
{
    verificationType: "byLink",
    resendTimeWindow: 60,
    expireTimeWindow: 86400
}
```


### Email Verification
The project supports email verification, allowing users to verify their email addresses securely through a verification code sent to their registered email address.
This service is useful for projects that require users to verify their email addresses securely, such as social networks, forums, or any application where email verification is required.
The email verification process is handled by the auth service, which will send a verification code to the user's email address after they register or change their email address.           
```json
{
    verificationType: "byLink",
    resendTimeWindow: 60,
    expireTimeWindow: 86400
}
```


### Mobile Verification
The project supports mobile verification, allowing users to verify their mobile numbers securely through a verification code sent to their registered mobile number.
This service is useful for projects that require users to verify their mobile numbers securely, such as social networks, forums, or any application where mobile verification is required.
The mobile verification process is handled by the auth service, which will send a verification code to the user's mobile number after they register or change their mobile number.           
```json
{      
    verificationType: "byLink",
    resendTimeWindow: 60,
    expireTimeWindow: 86400
}
```


### Email 2FA
The project supports email-based two-factor authentication (2FA), allowing users to enhance their login security
by providing a second factor of authentication, such as a verification code sent to their registered email address.
This service is useful for projects that require an additional layer of security for user login, such as social networks, forums, or any application where email-based 2FA is required.
The email 2FA process is handled by the auth service, which will send a verification code to the user's email address after they log in.
The user must provide the verification code to complete the login process.
```json
{
    verificationType: "byLink",
    resendTimeWindow: 60,      
    expireTimeWindow: 86400
}
```


### Mobile 2FA
The project supports mobile-based two-factor authentication (2FA), allowing users to enhance their login security
by providing a second factor of authentication, such as a verification code sent to their registered mobile number.
This service is useful for projects that require an additional layer of security for user login, such as    
social networks, forums, or any application where mobile-based 2FA is required.
The mobile 2FA process is handled by the auth service, which will send a verification code
to the user's mobile number after they log in.
The user must provide the verification code to complete the login process.
```json
{
    verificationType: "byLink",
    resendTimeWindow: 60,
    expireTimeWindow: 86400
}       
```










## Access Control (Not Configured)
The project does not support any access control mechanisms, meaning that users can access all resources without any restrictions.
If you want to add access control mechanisms, you can do so in the **Access Control** chapter of Mindbricks **Authentication Module**.









## Social Logins (Not Configured)
The project does not support any social logins, meaning that users cannot log in using their social media accounts.
If you want to add social logins, you can do so in the **Social Logins** chapter of Mindbricks **Authentication Module**.




## User Properties (Not Configured)
The project does not support any user properties, meaning that users can only have the default properties defined in the user data object.
If you want to add user properties, you can do so in the **User Properties** chapter of Mindbricks **Authentication Module**.

To see a detailed configuration of the user properties, please check the **User Data Object** docmentation below.





## Tenant Properties (Not Configured)
The project does not support any tenant properties, meaning that tenants can only have the default properties defined
in the `store` data object.
If you want to add tenant properties, you can do so in the **Tenant Properties** chapter of Mindbricks **Authentication Module**.   
To see a detailed configuretion of the tenant properties, please check the **store Data Object** docmentation below.



## Auth Service Data Objects
The service uses a **PostgreSQL** database for data storage, with the database name set to `salesai-auth-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.



| Object Name | Description | Public Access | Tenant Level  | 
|-------------|-------------|---------------| --------------| 
| `user` | A data object that stores the user information and handles login settings. | No |  Yes | 
| `userGroup` | A data object that stores the user group information. | Yes |  No | 
| `userGroupMember` | A data object that stores the members of the user group. | Yes |  No | 
| `store` | A data object that stores the information for store | No |  No | 




## user Data Object

### Object Overview
**Description:** A data object that stores the user information and handles login settings.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** No — If enabled, anonymous users may access this object’s data depending on route-level rules.
- **Tenant-Level Scope:** Yes — Enables data isolation per tenant by attaching a tenant ID field.


### Redis Entity Caching
This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.







### Composite Indexes

- **UniqueEmailInForATenant**: [storeId, email] 
This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `throwError`

An error will be thrown, preventing the insertion of conflicting data.






### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `email` | String | Yes |  A string value to represent the user&#39;s email. |
| `password` | String | Yes |  A string value to represent the user&#39;s password. It will be stored as hashed. |
| `fullname` | String | Yes | A string value to represent the fullname of the user |
| `avatar` | String | No | The avatar url of the user. A random avatar will be generated if not provided |
| `emailVerified` | Boolean | Yes | A boolean value to represent the email verification status of the user. |
| `storeId` | ID | Yes | An ID value to represent the tenant id of the store |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.



### Default Values
Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any crud route to set default values dynamically.

- **storeId**: 00000000-0000-0000-0000-000000000000

### Always Create with Default Values
Some of the default values are set to be always used when creating a new object, even if the property value is provided in the request body. It ensures that the property is always initialized with a default value when the object is created.

- **emailVerified**: Will be created with value `false`


### Constant Properties

`email` `storeId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`fullname` `avatar`

An update crud route created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update route's body parameters and can be updated by the user if any value is provided in the request body.

 
### Hashed Properties

`password`

Hashed properties are stored in the database as a hash value, providing an additional layer of security for sensitive data.


 

 

### Elastic Search Indexing

`email` `fullname` `emailVerified` `storeId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`email` `storeId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.




### Cache Select Properties

`email`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.


### Secondary Key Properties

`email` `storeId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.






### Filter Properties

`email` `password` `fullname` `avatar` `emailVerified` `storeId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **email**: String  has a filter named `email`

- **password**: String  has a filter named `password`

- **fullname**: String  has a filter named `fullname`

- **avatar**: String  has a filter named `avatar`

- **emailVerified**: Boolean  has a filter named `emailVerified`

- **storeId**: ID  has a filter named `storeId`





## userGroup Data Object

### Object Overview
**Description:** A data object that stores the user group information.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** Yes — If enabled, anonymous users may access this object’s data depending on route-level rules.
- **Tenant-Level Scope:** No — Enables data isolation per tenant by attaching a tenant ID field.


### Redis Entity Caching
This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.











### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `groupName` | String | Yes |  A string value to represent the group name. |
| `avatar` | String | No |  A string value to represent the groups icon. |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.





### Auto Update Properties

`groupName` `avatar`

An update crud route created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update route's body parameters and can be updated by the user if any value is provided in the request body.

 
### Hashed Properties

`avatar`

Hashed properties are stored in the database as a hash value, providing an additional layer of security for sensitive data.


 

 

### Elastic Search Indexing

`groupName`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.





### Cache Select Properties

`groupName`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.







### Filter Properties

`groupName` `avatar`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **groupName**: String  has a filter named `groupName`

- **avatar**: String  has a filter named `avatar`





## userGroupMember Data Object

### Object Overview
**Description:** A data object that stores the members of the user group.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** Yes — If enabled, anonymous users may access this object’s data depending on route-level rules.
- **Tenant-Level Scope:** No — Enables data isolation per tenant by attaching a tenant ID field.


### Redis Entity Caching
This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.







### Composite Indexes

- **uniqueUserInGroup**: [userId, groupId] 
This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `doUpdate`

The existing record will be updated with the new data.No error will be thrown.






### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `groupId` | ID | Yes |  An ID value to represent the group that the user is asssigned as a memeber to. |
| `userId` | ID | Yes |  An ID value to represent the user that is assgined as a member to the group. |
| `ownerId` | ID | Yes | An ID value to represent the admin user who assgined the member. |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.




### Constant Properties

`groupId` `userId` `ownerId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


 

 

 

### Elastic Search Indexing

`groupId` `userId` `ownerId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`groupId` `userId` `ownerId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.




### Cache Select Properties

`groupId` `userId` `ownerId`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.



### Relation Properties

`groupId` `userId` `ownerId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **groupId**: ID
Relation to `userGroup`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No

- **userId**: ID
Relation to `user`.id

The target object is a sibling object, meaning that the relation is a many-to-one or one-to-one relationship from this object to the target.

On Delete: Set Null
Required: No

- **ownerId**: ID
Relation to `user`.id

The target object is a sibling object, meaning that the relation is a many-to-one or one-to-one relationship from this object to the target.

On Delete: Set Null
Required: No


### Session Data Properties

`ownerId`

Session data properties are used to store data that is specific to the user session, allowing for personalized experiences and temporary data storage.
If a property is configured as session data, it will be automatically mapped to the related field in the user session during CRUD operations.
Note that session data properties can not be mutated by the user, but only by the system.

- **ownerId**: ID property will be mapped to the session parameter `userId`.





### Filter Properties

`groupId` `userId` `ownerId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **groupId**: ID  has a filter named `groupId`

- **userId**: ID  has a filter named `userId`

- **ownerId**: ID  has a filter named `ownerId`





## store Data Object

### Object Overview
**Description:** A data object that stores the information for store

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement. 
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration
- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** No — If enabled, anonymous users may access this object’s data depending on route-level rules.
- **Tenant-Level Scope:** No — Enables data isolation per tenant by attaching a tenant ID field.


### Redis Entity Caching
This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.











### Properties Schema

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | String | Yes | A string value to represent one word name of the store |
| `codename` | String | Yes | A string value to represent a unique code name for the store which is generated automatically using name |
| `fullname` | String | Yes | A string value to represent the fullname of the store |
| `avatar` | String | No | A string value represent the url of the store avatar. Keep null for random avatar. |
| `ownerId` | ID | Yes | An ID value to represent the user id of store owner who created the tenant |
* Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.




### Constant Properties

`ownerId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.


### Auto Update Properties

`name` `fullname` `avatar`

An update crud route created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body. 
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update route's body parameters and can be updated by the user if any value is provided in the request body.

 

 

 

### Elastic Search Indexing

`name` `codename` `fullname` `ownerId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API. 
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.


### Database Indexing

`ownerId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.


### Unique Properties

`codename`

Unique properties are enforced to have distinct values across all instances of the data object, preventing duplicate entries.
Note that a unique property is automatically indexed in the database so you will not need to set the `Indexed in DB` option.




### Secondary Key Properties

`ownerId`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.


### Relation Properties

`ownerId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **ownerId**: ID
Relation to `user`.id

The target object is a sibling object, meaning that the relation is a many-to-one or one-to-one relationship from this object to the target.

On Delete: Set Null
Required: No


### Session Data Properties

`ownerId`

Session data properties are used to store data that is specific to the user session, allowing for personalized experiences and temporary data storage.
If a property is configured as session data, it will be automatically mapped to the related field in the user session during CRUD operations.
Note that session data properties can not be mutated by the user, but only by the system.

- **ownerId**: ID property will be mapped to the session parameter `userId`.

This property is also used to store the owner of the session data, allowing for ownership checks and access control.





### Filter Properties

`name` `codename` `fullname` `avatar` `ownerId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **name**: String  has a filter named `name`

- **codename**: String  has a filter named `codename`

- **fullname**: String  has a filter named `fullname`

- **avatar**: String  has a filter named `avatar`

- **ownerId**: ID  has a filter named `ownerId`






